

 1. Сортировка выбором (в файле — Python)

Реализация на C++:

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Сортировка выбором
void selectionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j)
            if (arr[j] < arr[minIndex])
                minIndex = j;
        swap(arr[i], arr[minIndex]);
    }
}

int main() {
    vector<int> arr = {64, 25, 12, 22, 11};
    cout << "Исходный массив: ";
    for (int v : arr) cout << v << " ";
    cout << endl;

    selectionSort(arr);

    cout << "Отсортированный массив: ";
    for (int v : arr) cout << v << " ";
    cout << endl;
}
```
Объяснение: Ищет минимальный элемент в неотсортированной части и меняет его с первым элементом. 

 2. Сортировка обменом (пузырёк) (в файле — C++)

Реализация на Python:

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

if __name__ == "__main__":
    data = [64, 34, 25, 12, 22, 11, 90]
    print("Исходный массив:", data)
    bubble_sort(data)
    print("Отсортированный массив:", data)
```
Объяснение: Повторно сравнивает соседние элементы и меняет местами, пока не отсортирует весь массив.
***

 3. Сортировка вставками (в файле — Java)

Реализация на C++:

```cpp
#include <iostream>
#include <vector>
using namespace std;

void insertionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

int main() {
    vector<int> arr = {12, 11, 13, 5, 6};
    cout << "Исходный массив: ";
    for (int v : arr) cout << v << " ";
    cout << endl;

    insertionSort(arr);

    cout << "Отсортированный массив: ";
    for (int v : arr) cout << v << " ";
    cout << endl;
}
```
Объяснение: Вставляет элементы из неотсортированной части в отсортированную, сдвигая их.  4. Сортировка слиянием (в файле — Python)

Реализация на C++:

```cpp
#include <iostream>
#include <vector>
using namespace std;

void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) temp[k++] = arr[i++];
        else temp[k++] = arr[j++];
    }
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    for (int x = 0; x < temp.size(); x++) arr[left + x] = temp[x];
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left)/2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid+1, right);
        merge(arr, left, mid, right);
    }
}

int main() {
    vector<int> arr = {38, 27, 43, 3, 9, 82, 10};
    cout << "Исходный массив: ";
    for (int v : arr) cout << v << " ";
    cout << endl;

    mergeSort(arr, 0, arr.size()-1);

    cout << "Отсортированный массив: ";
    for (int v : arr) cout << v << " ";
    cout << endl;
}
```
 5. Сортировка Шелла (в файле — C++)

Реализация на Python:

```python
def shell_sort(arr):
    n = len(arr)
    gap = n // 2
    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            while j >= gap and arr[j-gap] > temp:
                arr[j] = arr[j-gap]
                j -= gap
            arr[j] = temp
        gap //= 2

if __name__ == "__main__":
    data = [12, 34, 54, 2, 3]
    print("Исходный массив:", data)
    shell_sort(data)
    print("Отсортированный массив:", data)
```
Объяснение: Улучшение сортировки вставками с интервалами gap, которые уменьшаются.



 6. Быстрая сортировка (в файле — Java)

Реализация на Python:

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[-1]
    left = [x for x in arr[:-1] if x <= pivot]
    right = [x for x in arr[:-1] if x > pivot]
    return quick_sort(left) + [pivot] + quick_sort(right)

if __name__ == "__main__":
    data = [10, 7, 8, 9, 1, 5]
    print("Исходный массив:", data)
    sorted_data = quick_sort(data)
    print("Отсортированный массив:", sorted_data)
```
Объяснение: Выбирает опорный элемент, рекурсивно сортирует левую и правую части.


 7. Поиск Фибоначчи (в файле — C++)

Реализация на Python:

```python
def fibonacci_search(arr, x):
    n = len(arr)
    fibMMm2, fibMMm1 = 0, 1
    fibM = fibMMm2 + fibMMm1

    while fibM < n:
        fibMMm2, fibMMm1 = fibMMm1, fibM
        fibM = fibMMm2 + fibMMm1

    offset = -1

    while fibM > 1:
        i = min(offset + fibMMm2, n - 1)
        if arr[i] < x:
            fibM, fibMMm1, fibMMm2 = fibMMm1, fibMMm2, fibM - fibMMm1
            offset = i
        elif arr[i] > x:
            fibM, fibMMm1, fibMMm2 = fibMMm2, fibMMm1 - fibMMm2, fibM - fibMMm1
        else:
            return i

    if fibMMm1 and offset + 1 < n and arr[offset + 1] == x:
        return offset + 1
    return -1

if __name__ == "__main__":
    arr = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
    x = 85
    res = fibonacci_search(arr, x)
    if res != -1:
        print(f"Элемент найден на позиции: {res}")
    else:
        print("Элемент не найден")
```

Объяснение: Алгоритм использует числа Фибоначчи для поиска элемента в отсортированном массиве.








 Пирамидальная сортировка (Heap Sort) — Реализация на Java

```java
import java.util.Arrays;

public class HeapSort {
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2*i + 1;
        int right = 2*i + 2;

        if (left < n && arr[left] > arr[largest])
            largest = left;
        if (right < n && arr[right] > arr[largest])
            largest = right;

        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;

            heapify(arr, n, largest);
        }
    }

    public static void heapSort(int[] arr) {
        int n = arr.length;

        // Построение max heap
        for (int i = n/2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // Извлечение элементов из кучи
        for (int i = n-1; i > 0; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            heapify(arr, i, 0);
        }
    }

    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        System.out.println("Исходный массив: " + Arrays.toString(arr));
        heapSort(arr);
        System.out.println("Отсортированный массив: " + Arrays.toString(arr));
    }
}
```
Объяснение: Строится куча (max-heap), затем максимальный элемент последовательно перемещается в конец массива, восстанавливая кучу.



 Последовательный поиск — Реализация на Java

```java
public class LinearSearch {
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++)
            if (arr[i] == target)
                return i;
        return -1;
    }
    public static void main(String[] args) {
        int[] arr = {3, 5, 2, 7, 9, 1, 4};
        int target = 7;
        int res = linearSearch(arr, target);
        System.out.println(res != -1 ? "Элемент найден на позиции: " + res : "Элемент не найден");
    }
}
```
Объяснение: Поиск слева направо до нахождения нужного элемента
 Бинарный поиск — Реализация на C++

```cpp
#include <iostream>
#include <vector>
using namespace std;

int binarySearch(const vector<int>& arr, int target) {
    int left = 0, right = (int)arr.size() - 1;
    while (left <= right) {
        int mid = left + (right - left)/2;
        if (arr[mid] == target)
            return mid;
        else if (arr[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return -1;
}

int main() {
    vector<int> arr = {1, 3, 5, 7, 9, 11};
    int target = 7;
    int res = binarySearch(arr, target);
    if (res != -1)
        cout << "Элемент найден на позиции: " << res << endl;
    else
        cout << "Элемент не найден" << endl;
}
```
Объяснение: Поиск в отсортированном массиве, деление зоны поиска, 

 Интерполирующий поиск — Реализация на Java

```java
public class InterpolationSearch {
    public static int interpolationSearch(int[] arr, int x) {
        int lo = 0, hi = arr.length - 1;
        while (lo <= hi && x >= arr[lo] && x <= arr[hi]) {
            int pos = lo + ((x - arr[lo]) * (hi - lo)) / (arr[hi] - arr[lo]);
            if (arr[pos] == x) return pos;
            if (arr[pos] < x) lo = pos + 1;
            else hi = pos - 1;
        }
        return -1;
    }
    public static void main(String[] args) {
        int[] arr = {10, 12, 13, 16, 18, 19, 20, 21, 22};
        int x = 18;
        int res = interpolationSearch(arr, x);
        System.out.println(res != -1 ? "Элемент найден на позиции: " + res : "Элемент не найден");
    }
}
```
Объяснение: Как бинарный, но прогнозирует позицию основываясь на значениях, более эффективен при равномерном распределении.


